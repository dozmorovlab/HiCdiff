---
title: Persistence of bias in individually normalized chromatin interaction matrices,
  and its effect on the detection of differential chromatin interactions
author: "John Stansfield, Mikhail Dozmorov"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# Set up the environment
library(knitr)
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=F, tidy=T, fig.keep='high', echo=F, dpi=100, warnings=F, message=F, comment=NA, warning=F, results='as.is', fig.width = 5, fig.height = 3) #out.width=700, 
library(pander)
panderOptions('table.split.table', Inf)
set.seed(1)
library(dplyr)
options(stringsAsFactors = FALSE)
```

```{r libraries}
library(HiCdiff)
library(chromoR)
library(pROC)
library(MLmetrics)
library(HiTC)
library(Matrix)
library(GenomicRanges)
library(ggplot2)
library(gridExtra)

```



```{r}
# load data
githubURL <- "https://github.com/dozmorovlab/HiCdiff/raw/supplemental/Supplemental_data/S1_File_data.RData"
load(url(githubURL))
```


# Introduction

To compare the ability of methods for normalizing individual datasets to remove biases _between_ chromatin interaction matrices, we compare individually normalized matrices with the jointly normalized ones. Several parameters were assessed:

- The effect of global differences. Most of the time different chromatin interaction matrices will contain different total number of reads, resulting in the overall differences. We assessed whether methods for normalizing individual datasets were able to account for the differences in the total number of reads.
- The ability of the joint normalization to account for biases under different conditions, such as when comparing matrices obtained with different cutting enzymes, or matrices from different chromosomes.
- The effect of individual and joint normalization methods on detecting chromatin interaction differences.



```{r}
## `hic.table` format

chr1.tab      <- create.hic.table(S1.dpnii.chr1,   S1.mbol.chr1,        chr = 'chr1')
chr11.tab     <- create.hic.table(S1.dpnii.chr11,  S1.mbol.chr11,       chr = 'chr11')
chr18.tab     <- create.hic.table(S1.dpnii.chr18,  S1.mbol.chr18,       chr = 'chr18')
chr19.tab     <- create.hic.table(S1.dpnii.chr19,  S1.mbol.chr19,       chr = 'chr19')
replicate.tab <- create.hic.table(S1.primary.chr1, S1.replicate.chr1,   chr = 'chr1')
rep.chr11.tab <- create.hic.table(S1.primary.chr11, S1.replicate.chr11, chr = 'chr1')
rep.chr18.tab <- create.hic.table(S1.primary.chr18, S1.replicate.chr18, chr = 'chr1')
rep.chr19.tab <- create.hic.table(S1.primary.chr19, S1.replicate.chr19, chr = 'chr1')

unscaled.tab       <- create.hic.table(S1.dpnii.chr1,  S1.mbol.chr1,  chr='chr1',  scale=F)
chr11.unscaled.tab <- create.hic.table(S1.dpnii.chr11, S1.mbol.chr11, chr='chr11', scale=F)

# BEDPE-like hic.table object
#head(chr1.tab)
```



## The effect of normalization methods on removing global differences

Hi-C matrices may have a different total number of reads. This disbalance will lead to the overall difference between the two matrices, reflected by the global shift of the cloud of $M$ differences from zero. The unscaled matrices, globally shifted from $M = 0$, can be successfully normalized by `loess`. However, individually normalized matrices will still contain the global shift, as shown below. By default, the `create.hic.table` function rescales the matrices to have the same total number of reads. Rescaling is accomplished by first calculating the scale factor $\psi = \frac{\sum IF_i}{\sum IF_j}$ where $i$ is the set of all the IFs for the upper triangle of the first Hi-C matrix and $j$ is the set of all IFs for the upper triangle of the second Hi-C matrix. Next, $IF_j$ is scaled by setting $IF_{j_{new}} = \frac{IF_j}{\psi}$.

### `loess`

```{r}
diffs = hic_loess(unscaled.tab,  Plot = T, check.differences = F, diff.thresh = NA)
```

### `ChromoR`

```{r}

# convert hic.table to full matrices for other methods to work
mat1 = sparse2full(unscaled.tab[, c('start1', 'start2', 'IF1'), with=F])
mat2 = sparse2full(unscaled.tab[, c('start1', 'start2', 'IF2'), with=F])

start = as.numeric(colnames(mat1))
end = as.numeric(colnames(mat1))
seg = data.frame(chr = chr11.tab$chr1[1], start = start, end = end)
# correct simulated matrices using chromoR's methods
sim1.chromor = correctCIM(mat1, seg)
sim2.chromor = correctCIM(mat2, seg)
colnames(sim1.chromor$mCorrected) = seg$start
colnames(sim2.chromor$mCorrected) = seg$start
sim1.chromor = full2sparse(sim1.chromor$mCorrected)
sim2.chromor = full2sparse(sim2.chromor$mCorrected)

chromoR.tab = create.hic.table(sim1.chromor, sim2.chromor, scale=F, chr = 'chr11')
chromoR.tab[, ':=' (adj.IF1 = IF1, adj.IF2 = IF2, adj.M = M)]

p1 = MD.plot2(unscaled.tab$M, unscaled.tab$D) + ggtitle('Before Normalization')
p2 = MD.plot2(chromoR.tab$M, chromoR.tab$D) + ggtitle('After Normalization')
grid.arrange(p1, p2, ncol = 2)
```

### `ICE`

```{r, message=FALSE}
sim1.ice = Matrix(mat1)
sim2.ice = Matrix(mat2)
# create HTCexp object for simulated data
xgi = GRanges(seqnames = 'chr11', ranges = IRanges(start = start, end  = end), names = paste('a', 1:length(start), sep=''))
ygi = GRanges(seqnames = 'chr11', ranges = IRanges(start = start, end  = end), names = paste('b', 1:length(start), sep=''))
sim1.ice = new('HTCexp', sim1.ice, xgi, ygi)
colnames(sim1.ice@intdata) <- id(xgi)
rownames(sim1.ice@intdata) <- id(ygi)
sim2.ice = new('HTCexp', sim2.ice, xgi, ygi)
colnames(sim2.ice@intdata) <- id(xgi)
rownames(sim2.ice@intdata) <- id(ygi)
# normalize with ICE
sim1.ice = normICE(sim1.ice, max_iter = 100)
sim2.ice = normICE(sim2.ice, max_iter = 100)
# convert to hic.table
colnames(sim1.ice@intdata) = start
colnames(sim2.ice@intdata) = start
sim1.ice = full2sparse(as.matrix(sim1.ice@intdata))
sim2.ice = full2sparse(as.matrix(sim2.ice@intdata))
ice.table = create.hic.table(sim1.ice, sim2.ice, scale = FALSE, chr = 'chr11')
ice.table[, ':=' (adj.IF1 = IF1, adj.IF2 = IF2, adj.M = M)]

p1 = MD.plot2(unscaled.tab$M, unscaled.tab$D) + ggtitle('Before Normalization')
p2 = MD.plot2(ice.table$M, ice.table$D) + ggtitle('After Normalization')
grid.arrange(p1, p2, ncol = 2)

```

### `KR`

```{r}
zeros1 = which(colSums(mat1) == 0)
zeros2 = which(colSums(mat2) == 0)
if (length(zeros1) > 0) {
  cr.mat1 = mat1[-zeros1, -zeros1]
} else {
  cr.mat1 = mat1
}
if (length(zeros2) > 0) {
  cr.mat2 = mat2[-zeros2, -zeros2]
} else {
  cr.mat2 = mat2
}
sim1.kr = KRnorm(cr.mat1)
sim2.kr = KRnorm(cr.mat2)
colnames(sim1.kr) = colnames(cr.mat1)
colnames(sim2.kr) = colnames(cr.mat2)
sim1.kr = full2sparse(sim1.kr)
sim2.kr = full2sparse(sim2.kr)
kr.table = create.hic.table(sim1.kr, sim2.kr, scale = FALSE, chr = 'chr11')
kr.table[, ':=' (adj.IF1 = IF1, adj.IF2 = IF2, adj.M = M)]

p1 = MD.plot2(unscaled.tab$M, unscaled.tab$D) + ggtitle('Before Normalization')
p2 = MD.plot2(kr.table$M, kr.table$D) + ggtitle('After Normalization')
grid.arrange(p1, p2, ncol = 2)

```

### `SCN`

```{r}
sim1.scn = SCN(mat1)
sim2.scn = SCN(mat2)
sim1.scn = full2sparse(sim1.scn)
sim2.scn = full2sparse(sim2.scn)
scn.table = create.hic.table(sim1.scn, sim2.scn, chr='chr11', scale=FALSE)
scn.table[, ':=' (adj.IF1 = IF1, adj.IF2 = IF2, adj.M = M)]

p1 = MD.plot2(unscaled.tab$M, unscaled.tab$D) + ggtitle('Before Normalization')
p2 = MD.plot2(scn.table$M, scn.table$D) + ggtitle('After Normalization')
grid.arrange(p1, p2, ncol = 2)

```

### Summary

As can be seen from the above, the MD plots for the single matrix normalization methods do not all succeed at rescaling the data and thus the main cloud of points are not centered around $M = 0$. `Loess` however, was able to take care of rescaling the data and centered the MD plot around 0. Global scaling is recommended for any comparisons between Hi-C datasets.

# The effect of `loess` normalization on removing chromosome-specific biases

## Common cutting enzyme

The MD plot below displays data before and after joint `loess` normalization from GM12878 at 1MB resolution, chromosome 1, that were obtained as replicates using the same cutting enzyme. Since the data here is replicate data it is expected that there will not be many differences between the datasets. Any differences found are assumed to be due to bias in the sequencing procedures. 

```{r}
### Chr 1

hic_loess(replicate.tab, Plot = T)
```



As can be seen by the loess fit on the "Before loess" MD plot there is not a large amount of bias between the two datasets.

## Different cutting enzymes

The Hi-C datasets here are from GM12878 cell lines at 1MB resolution, chromosome 1. One dataset was cut using MboI and the other using DpnII. Since different cutting enzymes are used it is expected that there will be some differences in the data due to enzyme choice. Biases between the datasets are successfully removed with `loess` normalization as can be seen in the following MD plots displaying the data before and after joint `loess` normalization. It can also be seen that biases between the datasets differ between each chromosome and dataset. The differences do not appear to follow a trend which makes a non-parametric approach to normalization better suited to the task.

```{r, warning=FALSE}
### Chr 1

hic_loess(chr1.tab,  Plot = T)
```



# The effect of normalization methods on detecting differential chromatin interactions

To look at differences between different normalization methods we use data from GM12878 at 1MB resolution on chr 11 generated using two different cutting enzymes, MboI and DpnII. The data is unscaled. For each method tested below, we also test for differences between the two datasets. No artificial changes were added to the datasets. Any differences detected by the method will be examples of existing differences between the replicated Hi-C data on the same cell line when cut by different enzymes. Since the datasets are for the same chromosome and the same cell line we should expect few differences to be detected.

## `loess`

```{r}
diffs = hic_loess(chr11.tab, Plot=T, check.differences = F)
```


```{r}
diffs = hic_diff(diffs, diff.thresh = 1, Plot=T)
tab = diffs
counts = sum(diffs$p.value < 0.05)
print(paste0(counts, ' differences found between the datasets'))
```

The MD plot above serves as a reference to show that `Loess` can successfully normalizes the data and removes bias between the two datasets. The following MD plots display the data after the specified individual normalization method has been applied to each matrix. The dotted lines on the second MD plot represent the difference threshold where points are considered significant outside of the two dotted lines. The difference threshold used here is $\theta = 1$, see `?hic_diff` and the methods section of the paper for a full explanation on the difference threshold.

## `ChromoR`

```{r}

# convert hic.table to full matrices for other methods to work
mat1 = sparse2full(chr11.tab[, c('start1', 'start2', 'IF1'), with=F])
mat2 = sparse2full(chr11.tab[, c('start1', 'start2', 'IF2'), with=F])

start = as.numeric(colnames(mat1))
end = as.numeric(colnames(mat1))
seg = data.frame(chr = chr11.tab$chr1[1], start = start, end = end)
# correct simulated matrices using chromoR's methods
sim1.chromor = correctCIM(mat1, seg)
sim2.chromor = correctCIM(mat2, seg)
colnames(sim1.chromor$mCorrected) = seg$start
colnames(sim2.chromor$mCorrected) = seg$start
sim1.chromor = full2sparse(sim1.chromor$mCorrected)
sim2.chromor = full2sparse(sim2.chromor$mCorrected)

chromoR.tab = create.hic.table(sim1.chromor, sim2.chromor, scale=F, chr = 'chr11')
chromoR.tab[, ':=' (adj.IF1 = IF1, adj.IF2 = IF2, adj.M = M)]

p1 = MD.plot2(tab$M, tab$D) + ggtitle('Before Normalization')
p2 = MD.plot2(chromoR.tab$M, chromoR.tab$D) + ggtitle('After Normalization')
grid.arrange(p1, p2, ncol = 2)
```


```{r}
diffs = hic_diff(chromoR.tab, Plot = T, diff.thresh = 1)
counts = sum(diffs$p.value < 0.05)
print(paste0(counts, ' differences found between the datasets'))
```

## `ICE`

```{r, message=F}

sim1.ice = Matrix(mat1)
sim2.ice = Matrix(mat2)
# create HTCexp object for simulated data
xgi = GRanges(seqnames = 'chr11', ranges = IRanges(start = start, end  = end), names = paste('a', 1:length(start), sep=''))
ygi = GRanges(seqnames = 'chr11', ranges = IRanges(start = start, end  = end), names = paste('b', 1:length(start), sep=''))
sim1.ice = new('HTCexp', sim1.ice, xgi, ygi)
colnames(sim1.ice@intdata) <- id(xgi)
rownames(sim1.ice@intdata) <- id(ygi)
sim2.ice = new('HTCexp', sim2.ice, xgi, ygi)
colnames(sim2.ice@intdata) <- id(xgi)
rownames(sim2.ice@intdata) <- id(ygi)
# normalize with ICE
sim1.ice = normICE(sim1.ice, max_iter = 100)
sim2.ice = normICE(sim2.ice, max_iter = 100)
# convert to hic.table
colnames(sim1.ice@intdata) = start
colnames(sim2.ice@intdata) = start
sim1.ice = full2sparse(as.matrix(sim1.ice@intdata))
sim2.ice = full2sparse(as.matrix(sim2.ice@intdata))
ice.table = create.hic.table(sim1.ice, sim2.ice, scale = FALSE, chr = 'chr11')

ice.table[, ':=' (adj.IF1 = IF1, adj.IF2 = IF2, adj.M = M)]

p1 = MD.plot2(tab$M, tab$D) + ggtitle('Before Normalization')
p2 = MD.plot2(ice.table$M, ice.table$D) + ggtitle('After Normalization')
grid.arrange(p1, p2, ncol = 2)
```


```{r}
diffs = hic_diff(ice.table, Plot = T, diff.thresh = 1)
counts = sum(diffs$p.value < 0.05)
print(paste0(counts, ' differences found between the datasets'))
```

## `KR`

```{r}
zeros1 = which(colSums(mat1) == 0)
zeros2 = which(colSums(mat2) == 0)
if (length(zeros1) > 0) {
  cr.mat1 = mat1[-zeros1, -zeros1]
} else {
  cr.mat1 = mat1
}
if (length(zeros2) > 0) {
  cr.mat2 = mat2[-zeros2, -zeros2]
} else {
  cr.mat2 = mat2
}
sim1.kr = KRnorm(cr.mat1)
sim2.kr = KRnorm(cr.mat2)
colnames(sim1.kr) = colnames(cr.mat1)
colnames(sim2.kr) = colnames(cr.mat2)
sim1.kr = full2sparse(sim1.kr)
sim2.kr = full2sparse(sim2.kr)
kr.table = create.hic.table(sim1.kr, sim2.kr, scale = FALSE, chr = 'chr11')

kr.table[, ':=' (adj.IF1 = IF1, adj.IF2 = IF2, adj.M = M)]

p1 = MD.plot2(tab$M, tab$D) + ggtitle('Before Normalization')
p2 = MD.plot2(kr.table$M, kr.table$D) + ggtitle('After Normalization')
grid.arrange(p1, p2, ncol = 2)
```


```{r}
diffs = hic_diff(kr.table, Plot = T, diff.thresh = 1)
counts = sum(diffs$p.value < 0.05)
print(paste0(counts, ' differences found between the datasets'))
```

## `SCN`

```{r}
sim1.scn = SCN(mat1)
sim2.scn = SCN(mat2)
sim1.scn = full2sparse(sim1.scn)
sim2.scn = full2sparse(sim2.scn)
scn.table = create.hic.table(sim1.scn, sim2.scn, chr='chr11', scale=FALSE)

scn.table[, ':=' (adj.IF1 = IF1, adj.IF2 = IF2, adj.M = M)]

p1 = MD.plot2(tab$M, tab$D) + ggtitle('Before Normalization')
p2 = MD.plot2(scn.table$M, scn.table$D) + ggtitle('After Normalization')
grid.arrange(p1, p2, ncol = 2)
```


```{r}
diffs = hic_diff(scn.table, Plot = T, diff.thresh = 1)
counts = sum(diffs$p.value < 0.05)
print(paste0(counts, ' differences found between the datasets'))
```

### Summary

`Loess` is the only method that can successfully remove the bias between the two datasets. The individual normalization techniques fail to remove biases between the datasets though they may be effective at removing bias within a single dataset. `KR` normalization appears to be second to the `loess` normalization in removing global and local biases.


# Comparison of `HiCdiff` vs. `ChromoR` in detecting differential chromatin interactions

`ChromoR` includes a function for detecting differences between two Hi-C datasets. Using the data for chromosome 11 from GM12878 as used in the above normalization comparison we add 200 _a priori_ known differences to the matrix at a 5 fold change and attempt to detect them using `ChromoR` and `loess`

```{r}
# add differences 
changes = sample(1:nrow(chr11.unscaled.tab), 200)
whichIF = ifelse(chr11.unscaled.tab[changes, ]$M < 0, -1, 1)
newIF1 = 5^whichIF * chr11.unscaled.tab[changes,]$IF1
newIF1 = as.integer(round(newIF1))
chr11.unscaled.tab[changes,]$IF1 = newIF1
chr11.unscaled.tab = chr11.unscaled.tab[, M := log2(IF2/IF1)]

mat1 = chr11.unscaled.tab[, c('start1', 'start2', 'IF1'), with=F] %>% sparse2full()
mat2 = chr11.unscaled.tab[, c('start1', 'start2', 'IF2'), with=F] %>% sparse2full()
sim1.chromor = correctCIM(mat1, seg)
sim2.chromor = correctCIM(mat2, seg)
colnames(sim1.chromor$mCorrected) = seg$start
colnames(sim2.chromor$mCorrected) = seg$start

chromoR.result = compareCIM(sim1.chromor$mCorrected, sim2.chromor$mCorrected, seg)
num.diffs = nrow(chromoR.result$sigChanges)

cr1 = sim1.chromor$mCorrected %>% full2sparse()
cr2 = sim2.chromor$mCorrected %>% full2sparse()
chromoR.result = create.hic.table(cr1, cr2, chr='chr11')
```

The MD plot of the `ChromoR` normalized matrices:
   
```{r}
p1 = MD.plot2(chr11.unscaled.tab$M, chr11.unscaled.tab$D) + ggtitle('Before Normalization')
p2 = MD.plot2(chromoR.result$M, chromoR.result$D) + ggtitle('After Normalization')
grid.arrange(p1, p2, ncol = 2)
```


```{r}
MD.plot2(chromoR.result$M, chromoR.result$D, p.val = 1)
```

`ChromoR` found `r num.diffs` differences between the two matrices. Compared to `hic_loess` below:

```{r}
loess.diffs = hic_loess(chr11.unscaled.tab, check.differences = F, Plot = T)
```


```{r}
loess.diffs = hic_diff(loess.diffs, Plot = T, diff.thresh = 1)
loess.diffs = sum(loess.diffs$p.value < 0.05)
```

`Loess` found `r loess.diffs` differences between the matrices.

`ChromoR`'s normalization technique fails to remove bias between Hi-C datasets and it's difference detection method also fails to detect any differences when true differences are added at a 5 fold change. `Loess` was capable of normalizing these datasets and detecting the majority of the true differences added to the matrices.

